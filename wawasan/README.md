
No Peserta : 30220038
Aditya     : Aditya

Wawasan

1.) Software Engineering (Rekayasa perangkat lunak)
	Rekayasa Perangkat Lunak (RPL, atau dalam bahasa Inggris: Software Engineering atau SE) adalah satu bidang profesi yang mendalami cara-cara pengembangan perangkat lunak termasuk pembuatan, pemeliharaan, manajemen organisasi pengembangan perangkat lunak dan manajemen kualitas.

	IEEE Computer Society mendefinisikan rekayasa perangkat lunak sebagai penerapan suatu pendekatan yang sistematis, disiplin dan terkuantifikasi atas pengembangan, penggunaan dan pemeliharaan perangkat lunak, serta studi atas pendekatan-pendekatan ini, yaitu penerapan pendekatan engineering atas perangkat lunak.

	Rekayasa perangkat lunak adalah pengubahan perangkat lunak itu sendiri guna mengembangkan, memelihara, dan membangun kembali dengan menggunakan prinsip rekayasa untuk menghasilkan perangkat lunak yang dapat bekerja lebih efisien dan efektif untuk pengguna.

	Kriteria yang dapat digunakan sebagai acuan dalam merekayasa perangkat lunak:

	1.) Dapat terus dirawat dan dipelihara (Maintainability)
	2.) Dapat mengikuti perkembangan teknologi (Dependability)
	3.) Dapat mengikuti keinginan pengguna (Robust)
	4.) Efektif dan efisien dalam menggunakan energi dan penggunaannya
	5.) Dapat memenuhi kebutuhan yang diinginkan (Usability)

	- Sejarah
	Istilah software engineering, pertama kali digunakan pada akhir tahun 1950-an dan sekitar awal 1960-an. Pada tahun 1968, NATO menyelenggarakan konferensi tentang software engineering di Jerman dan kemudian dilanjutkan pada tahun 1969. Meski penggunaan kata software engineering masukan konferensi tersebut menimbulkan debat tajam tentang aspek engineering dari pengembangan perangkat lunak, banyak pihak yang menganggap konferensi tersebutlah yang menjadi awal tumbuhnya profesi rekayasa perangkat lunak.

2.) Software configuration management (Manajemen konfigurasi perangkat lunak)
	Dalam rekayasa perangkat lunak , manajemen konfigurasi perangkat lunak ( SCM atau S/W CM ) adalah tugas melacak dan mengendalikan perubahan dalam perangkat lunak, bagian dari bidang manajemen konfigurasi lintas disiplin yang lebih besar .  Praktik SCM mencakup kontrol revisi dan penetapan baseline . Jika terjadi kesalahan, SCM dapat menentukan "apa, kapan, mengapa, dan siapa" dari perubahan tersebut. Jika konfigurasi berfungsi dengan baik, SCM dapat menentukan cara mereplikasinya di banyak host.

	Akronim "SCM" juga diperluas sebagai proses manajemen konfigurasi sumber dan perubahan perangkat lunak dan manajemen konfigurasi . Namun, "konfigurasi" umumnya dipahami untuk mencakup perubahan yang biasanya dibuat oleh administrator sistem .

	- Tujuan 
		1.) Identifikasi konfigurasi - Mengidentifikasi konfigurasi, item konfigurasi, dan garis dasar .
		2.) Kontrol konfigurasi - Menerapkan proses perubahan yang terkontrol . Ini biasanya dicapai 3.) dengan menyiapkan papan kontrol perubahan yang fungsi utamanya adalah untuk menyetujui atau menolak semua permintaan perubahan yang dikirim terhadap garis dasar apa pun.
		3.) Akuntansi status konfigurasi - Merekam dan melaporkan semua informasi yang diperlukan tentang status proses pengembangan.
		4.) Audit konfigurasi - Memastikan bahwa konfigurasi berisi semua bagian yang dimaksudkan dan sesuai dengan dokumen yang ditentukan, termasuk persyaratan, spesifikasi arsitektur, dan manual pengguna.
		5.) Membangun manajemen - Mengelola proses dan alat yang digunakan untuk membangun.
		6.) Manajemen proses - Memastikan kepatuhan terhadap proses pengembangan organisasi.
		7.) Manajemen lingkungan - Mengelola perangkat lunak dan perangkat keras yang menjadi tuan rumah sistem.
		8.) Kerja tim - Memfasilitasi interaksi tim yang terkait dengan proses.
		9.) Pelacakan cacat - Memastikan setiap cacat memiliki ketertelusuran kembali ke sumbernya.
		
		Dengan diperkenalkannya komputasi awan dan DevOps , tujuan alat SCM telah digabungkan dalam beberapa kasus. Alat SCM sendiri telah menjadi peralatan virtual yang dapat dipakai sebagai mesin virtual dan disimpan dengan status dan versi. Alat tersebut dapat memodelkan dan mengelola sumber daya virtual berbasis cloud, termasuk peralatan virtual, unit penyimpanan, dan bundel perangkat lunak. Peran dan tanggung jawab para aktor telah digabung juga dengan pengembang yang sekarang dapat membuat instance server virtual dan sumber daya terkait secara dinamis.

	- Sejarah
	Sejarah manajemen konfigurasi perangkat lunak (SCM) dalam komputasi dapat ditelusuri kembali pada awal 1950-an, ketika CM (untuk Manajemen Konfigurasi), awalnya untuk pengembangan perangkat keras dan kontrol produksi, sedang diterapkan untuk pengembangan perangkat lunak. Perangkat lunak awal memiliki jejak fisik, seperti kartu , kaset , dan media lainnya. Manajemen konfigurasi perangkat lunak pertama adalah operasi manual. Dengan kemajuan dalam bahasa dan kompleksitas, rekayasa perangkat lunak , yang melibatkan manajemen konfigurasi dan metode lainnya, menjadi perhatian utama karena masalah seperti jadwal, anggaran, dan kualitas. Pelajaran praktis, selama bertahun-tahun, telah mengarah pada definisi, dan penetapan, prosedur dan alat. Akhirnya, alat tersebut menjadi sistem untuk mengelola perubahan perangkat lunak. Praktik di seluruh industri ditawarkan sebagai solusi, baik secara terbuka atau kepemilikan (seperti Sistem Kontrol Revisi ). Dengan meningkatnya penggunaan komputer, muncul sistem yang menangani lingkup yang lebih luas, termasuk manajemen persyaratan , alternatif desain, kontrol kualitas, dan banyak lagi; alat kemudian mengikuti pedoman organisasi, seperti Model Kematangan Kemampuan dari Institut Rekayasa Perangkat Lunak .

3.) Version control (Kendali versi)
	Kendali versi (atau disebut juga pengontrol versi atau pengontrol revisi) merupakan suatu sistem pengelolaan berbagai revisi atas perubahan dari suatu unit informasi baik berupa dokumen, kode sumber, ataupun informasi lainnya yang disimpan dalam media penyimpanan komputer. Setiap entitas perubahan biasanya diidentifikasikan dalam bentuk kode numerik ataupun serangkaian karakter yang diistilahkan sebagai "nomor revisi" atau sederhananya disebut "revisi". Misalnya sekumpulan berkas yang disertakan saat inisialisasi disebut sebagai "revisi 1", kemudian saat terjadi perubahaan atas satu atau beberapa berkas yang ada disebut sebagai "revisi 2", dan seterusnya. Tiap-tiap revisi diasosiasikan dengan stempel waktu serta pengguna yang melakukan perubahan tersebut. Sebuah revisi dapat diperbandingkan, dikembalikan, ataupun digabungkan dengan beberapa jenis berkas yang lain.

	Kebutuhan untuk mengelola revisi atas perubahan yang dilakukan pada dasarnya telah lama muncul bersamaan dengan saat kemampuan menulis dikenal oleh manusia, hanya saja kebutuhan tersebut menjadi sangat penting seiring dengan dimulainya era komputasi. "Edisi" yang biasanya terdapat pada buku misalnya, merupakan contoh umum penggambaran atas manajemen revisi pada dunia percetakan.

	Sistem kendali versi (VCS) umumnya merupakan aplikasi mandiri, namun ada pula yang berfungsi sebagai sub modul dalam berbagai jenis aplikasi seperti pengolah kata (misalnya: OpenOffice Writer, Microsoft Word, KOffice), lembar kerja (spreadsheet) (misalnya: OpenOffice Calc, Microsoft Access), dan berbagai macam sistem manajemen konten. Integrasi terhadap kendali revisi ini merupakan salah satu fitur penting yang dimiliki perangkat lunak wiki seperti ((misalnya: MediaWiki), DokuWiki, TWiki, dan lain-lain). Dalam wiki, keberadaan kendali revisi memungkinkan pengembalian artikel kembali ke revisi sebelumnya yang sangat penting bagi penulis, ataupun kontributor untuk melacak perubahan yang dilakukan oleh pengguna lainnya, mengoreksi kesalahan, dan mempertahankan wiki terbuka dari vandalisme, ataupun spam.

	Perangkat lunak pembantu untuk mengendalikan revisi saat ini semakin lebih dikenal karena keberadaannya semakin diperlukan utamanya oleh organisasi yang memiliki tim pengembang, yang melibatkan lebih dari satu orang penulis kode dalam pengerjaan proyek perangkat lunak. Sistem ini utamanya digunakan dalam proses pengembangan perangkat lunak di mana tiap anggota dalam tim pengembang dapat saling melakukan perubahan terhadap sebuah berkas yang sama.

4.) Distributed version control (Kontrol versi terdistribusi)
	Dalam pengembangan perangkat lunak , kontrol versi terdistribusi (juga dikenal sebagai kontrol revisi terdistribusi ) adalah bentuk kontrol versi di mana basis kode lengkap , termasuk riwayat lengkapnya, dicerminkan pada setiap komputer pengembang. Dibandingkan dengan kontrol versi terpusat, ini memungkinkan percabangan dan penggabungan manajemen otomatis , mempercepat sebagian besar operasi (kecuali mendorong dan menarik), meningkatkan kemampuan untuk bekerja secara offline, dan tidak bergantung pada satu lokasi untuk pencadangan. Git , sistem kontrol versi paling populer di dunia, adalah sistem kontrol versi terdistribusi.

	Pada tahun 2010, penulis pengembangan perangkat lunak Joel Spolsky menggambarkan sistem kontrol versi terdistribusi sebagai "kemungkinan kemajuan terbesar dalam teknologi pengembangan perangkat lunak dalam sepuluh tahun terakhir".

	- Terdistribusi vs. terpusat
	Sistem kontrol versi terdistribusi (DVCS) menggunakan pendekatan peer-to-peer untuk kontrol versi, sebagai lawan dari pendekatan client-server dari sistem terpusat. Kontrol revisi terdistribusi menyinkronkan repositori dengan mentransfer tambalan dari rekan ke rekan. Tidak ada versi pusat tunggal dari basis kode; sebagai gantinya, setiap pengguna memiliki copy pekerjaan dan riwayat perubahan lengkap.

	Keuntungan DVCS (dibandingkan dengan sistem terpusat) meliputi:

	Memungkinkan pengguna untuk bekerja secara produktif saat tidak terhubung ke jaringan.
	Operasi umum (seperti komit, melihat riwayat, dan mengembalikan perubahan) lebih cepat untuk DVCS, karena tidak perlu berkomunikasi dengan server pusat.  Dengan DVCS, komunikasi hanya diperlukan saat berbagi perubahan di antara rekan-rekan lainnya.
	Mengizinkan pekerjaan pribadi, sehingga pengguna dapat menggunakan perubahan mereka bahkan untuk draf awal yang tidak ingin mereka terbitkan. ujukan? ]
	Salinan kerja berfungsi secara efektif sebagai cadangan jarak jauh, yang menghindari ketergantungan pada satu mesin fisik sebagai satu titik kegagalan. 
	Mengizinkan berbagai model pengembangan untuk digunakan, seperti menggunakan cabang pengembangan atau model Komandan/Letnan. ujukan? ]
	Mengizinkan kontrol terpusat dari "versi rilis" proyek ujukan? ]
	Pada proyek perangkat lunak FOSS , jauh lebih mudah untuk membuat garpu proyek dari proyek yang terhenti karena konflik kepemimpinan atau ketidaksepakatan desain.
	Kekurangan DVCS (dibandingkan dengan sistem terpusat) meliputi:

	Checkout awal repositori lebih lambat dibandingkan dengan checkout di sistem kontrol versi terpusat, karena semua cabang dan riwayat revisi disalin ke mesin lokal secara default.
	Kurangnya mekanisme penguncian yang merupakan bagian dari VCS paling terpusat dan masih memainkan peran penting dalam hal file biner yang tidak dapat digabungkan seperti aset grafik atau paket biner atau XML file tunggal yang terlalu kompleks (misalnya dokumen kantor, file PowerBI, SQL Server Paket Data Tools BI, dll.). ujukan? ]
	Penyimpanan tambahan diperlukan bagi setiap pengguna untuk memiliki salinan lengkap dari riwayat basis kode yang lengkap. 
	Peningkatan paparan basis kode karena setiap peserta memiliki salinan yang rentan secara lokal. ujukan? ]
	Beberapa sistem yang awalnya terpusat sekarang menawarkan beberapa fitur terdistribusi. Misalnya, Subversion mampu melakukan banyak operasi tanpa jaringan.  Team Foundation Server dan Visual Studio Team Services kini menghosting repositori kontrol versi terpusat dan terdistribusi melalui hosting Git.

	Demikian pula, beberapa sistem terdistribusi sekarang menawarkan fitur yang mengurangi masalah waktu checkout dan biaya penyimpanan, seperti Sistem File Virtual untuk Git yang dikembangkan oleh Microsoft untuk bekerja dengan basis kode yang sangat besar,  yang memperlihatkan sistem file virtual yang mengunduh file ke penyimpanan lokal hanya jika diperlukan.

5.) Git 
	Git ( / t / ) adalah perangkat lunak bebas dan sumber terbuka untuk kontrol versi terdistribusi : melacak perubahan dalam kumpulan file apa pun , biasanya digunakan untuk mengoordinasikan pekerjaan di antara pemrogram yang secara kolaboratif mengembangkan kode sumber selama pengembangan perangkat lunak . Sasarannya mencakup kecepatan, integritas data , dan dukungan untuk alur kerja non-linier terdistribusi (ribuan cabang paralel yang berjalan pada sistem yang berbeda).

	Git awalnya ditulis oleh Linus Torvalds pada tahun 2005 untuk pengembangan kernel Linux , dengan pengembang kernel lain berkontribusi pada pengembangan awal. Sejak tahun 2005, Junio Hamano telah menjadi pemelihara inti. Seperti kebanyakan sistem kontrol versi terdistribusi lainnya , dan tidak seperti kebanyakan sistem client-server , setiap direktori Git di setiap komputer adalah repositori lengkap dengan riwayat lengkap dan kemampuan pelacakan versi lengkap, independen dari akses jaringan atau server pusat. Git adalah perangkat lunak sumber terbuka dan gratis yang didistribusikan di bawah GPL-2.0 sajalisensi.

6.) Getting Started - About Version Control (Memulai - Tentang Kontrol Versi)
	Tentang Kontrol Versi
	Apa itu "kontrol versi", dan mengapa Anda harus peduli? Kontrol versi adalah sistem yang merekam perubahan pada file atau kumpulan file dari waktu ke waktu sehingga Anda dapat mengingat versi tertentu nanti. Untuk contoh dalam buku ini, Anda akan menggunakan kode sumber perangkat lunak sebagai file yang dikontrol versinya, meskipun pada kenyataannya Anda dapat melakukannya dengan hampir semua jenis file di komputer.

	Jika Anda seorang desainer grafis atau web dan ingin menyimpan setiap versi gambar atau tata letak (yang pasti Anda inginkan), Sistem Kontrol Versi (VCS) adalah hal yang sangat bijaksana untuk digunakan. Ini memungkinkan Anda untuk mengembalikan file yang dipilih kembali ke keadaan sebelumnya, mengembalikan seluruh proyek kembali ke keadaan sebelumnya, membandingkan perubahan dari waktu ke waktu, melihat siapa yang terakhir mengubah sesuatu yang mungkin menyebabkan masalah, siapa yang menimbulkan masalah dan kapan, dan banyak lagi. Menggunakan VCS juga umumnya berarti bahwa jika Anda mengacaukan atau kehilangan file, Anda dapat dengan mudah memulihkannya. Selain itu, Anda mendapatkan semua ini dengan biaya overhead yang sangat sedikit.

	Sistem Kontrol Versi Lokal
	Metode kontrol versi pilihan banyak orang adalah menyalin file ke direktori lain (mungkin direktori yang diberi cap waktu, jika mereka pintar). Pendekatan ini sangat umum karena sangat sederhana, tetapi juga sangat rawan kesalahan. Sangat mudah untuk melupakan direktori tempat Anda berada dan secara tidak sengaja menulis ke file yang salah atau menyalin file yang tidak Anda maksudkan.

	Untuk mengatasi masalah ini, programmer sejak lama mengembangkan VCS lokal yang memiliki database sederhana yang menyimpan semua perubahan pada file di bawah kendali revisi.

	Salah satu alat VCS yang paling populer adalah sistem yang disebut RCS, yang masih didistribusikan dengan banyak komputer saat ini. RCS bekerja dengan menyimpan set tambalan (yaitu, perbedaan antar file) dalam format khusus pada disk; itu kemudian dapat membuat kembali seperti apa file apa pun kapan saja dengan menambahkan semua tambalan.

	Sistem Kontrol Versi Terpusat
	Masalah utama berikutnya yang dihadapi orang adalah bahwa mereka perlu berkolaborasi dengan pengembang di sistem lain. Untuk mengatasi masalah ini, Sistem Kontrol Versi Terpusat (CVCS) dikembangkan. Sistem ini (seperti CVS, Subversion, dan Perforce) memiliki satu server yang berisi semua file berversi, dan sejumlah klien yang memeriksa file dari tempat pusat itu.

	Pengaturan ini menawarkan banyak keuntungan, terutama dibandingkan VCS lokal. Misalnya, semua orang tahu sampai tingkat tertentu apa yang dilakukan orang lain dalam proyek. Administrator memiliki kontrol yang halus atas siapa yang dapat melakukan apa, dan mengelola CVCS jauh lebih mudah daripada menangani database lokal pada setiap klien.

	Namun, pengaturan ini juga memiliki beberapa kelemahan serius. Yang paling jelas adalah titik kegagalan tunggal yang diwakili oleh server terpusat. Jika server itu mati selama satu jam, maka selama jam itu tidak ada yang bisa berkolaborasi sama sekali atau menyimpan perubahan berversi ke apa pun yang sedang mereka kerjakan. Jika hard disk tempat basis data pusat menjadi rusak, dan pencadangan yang tepat belum disimpan, Anda benar-benar kehilangan segalanya — seluruh riwayat proyek kecuali snapshot tunggal apa pun yang dimiliki orang di mesin lokal mereka. VCS lokal mengalami masalah yang sama — setiap kali Anda memiliki seluruh riwayat proyek di satu tempat, Anda berisiko kehilangan segalanya.

	Sistem Kontrol Versi Terdistribusi
	Di sinilah Sistem Kontrol Versi Terdistribusi (DVCS) masuk. Dalam DVCS (seperti Git, Mercurial, Bazaar atau Darcs), klien tidak hanya memeriksa snapshot file terbaru; melainkan, mereka sepenuhnya mencerminkan repositori, termasuk riwayat lengkapnya. Jadi, jika ada server yang mati, dan sistem ini berkolaborasi melalui server itu, repositori klien mana pun dapat disalin kembali ke server untuk memulihkannya. Setiap klon benar-benar merupakan cadangan lengkap dari semua data.

	Selain itu, banyak dari sistem ini menangani cukup baik dengan memiliki beberapa repositori jarak jauh yang dapat mereka gunakan, sehingga Anda dapat berkolaborasi dengan kelompok orang yang berbeda dengan cara yang berbeda secara bersamaan dalam proyek yang sama. Ini memungkinkan Anda untuk menyiapkan beberapa jenis alur kerja yang tidak mungkin dilakukan di sistem terpusat, seperti model hierarkis.

7.) Dasar-dasar Git
	Jadi, mudahnya, apakah Git itu? Ini adalah bab yang penting untuk dipahami, karena jika Anda memahami apa itu Git dan pemahaman dasar tentang bagaimana Git bekerja, maka, menggunakan Git dengan efektif mungkin akan menjadi lebih mudah Anda lakukan. Selama Anda belajar Git, cobalah untuk menjernihkan pikiran Anda dari hal-hal yang Anda ketahui tentang VCS lainnya, seperti Subversion dan Perforce; dengan begitu, akan membantu Anda menghindari hal-hal yang membingungkan ketika menggunakan alatnya. Git menyimpan dan berpikir tentang informasi dengan sangat berbeda daripada sistem lainnya, meskipun antarmuka penggunanya cukup mirip, dan memahami perbedaan-perbedaan tersebut akan membantu mencegah Anda menjadi bingung ketika menggunakannya.

	Snapshots, Bukan Perbedaan-perbedaan
	Perbedaan besar antara Git dan VCS lainnya (Subversion dan sejenisnya) adalah tentang cara Git berpikir tentang datanya. Secara konsep, kebanyakan sistem lain menyimpan informasi sebagai sebuah daftar dari perubahan-perubahan berbasis berkas. Sistem-sistem tersebut (CVS, Subversion, Perforce, Bazaar, dan seterusnya) berpikir tentang informasi yang mereka simpan sebagai sekumpulan berkas dan perubahan-perubahan yang dibuat kepada tiap berkas sepanjang waktu.

	Menyimpan data sebagai perubahan-perubahan ke sebuah versi dasar dari tiap berkas.
	Git tidak berpikir atau menyimpan datanya dengan cara ini. Namun, Git berpikir tentang datanya lebih seperti sekumpulan snapshot dari sebuah miniatur filesystem. Setiap kali Anda melakukan commit, atau menyimpan keadaan dari proyek Anda di Git, pada dasarnya itu mengambil sebuah gambar tentang bagaimana tampilan semua berkas Anda pada saat itu dan menyimpan acuan kepada snapshot tersebut. Singkatnya, jika berkas-berkas itu tidak berubah, Git tidak menyimpan berkasnya lagi, hanya menautkan ke berkas yang sama persis sebelumnya yang telah tersimpan. Git berpikir tentang datanya lebih seperti sebuah aliran snapshot.

	Git menyimpan data sebagai snapshot dari proyek sepanjang waktu.
	Ini adalah perbedaan penting antara Git dan hampir semua VCS lainnya. Hal itu membuat Git mempertimbangkan ulang hampir semua aspek dari version control yang kebanyakan sistem lainnya tiru dari generasi sebelumnya. Ini membuat Git lebih seperti sebuah filesystem kecil dengan beberapa alat yang sangat hebat terpasang padanya, daripada hanya sebuah VCS sederhana. Kita akan menjelajahi beberapa keuntungan yang Anda dapatkan dengan berpikir tentang data Anda seperti ini ketika kami membahas percabangan Git pada [_percabangan_git].

	Hampir Setiap Pekerjaan Adalah Lokal
	Kebanyakan pekerjaan pada Git hanya membutuhkan berkas-berkas dan sumber daya lokal untuk bekerja – secara umum, tidak ada informasi yang dibutuhkan dari komputer lain dalam jaringan Anda. Jika Anda terbiasa dengan CVCS di mana kebanyakan pekerjaan memiliki kelebihan network latency, aspek ini dalam Git akan membuat Anda berpikir bahwa Tuhan telah memberkati Git dengan kekuatan yang tak dapat diungkapkan dengan kata-kata. Karena, jika Anda memiliki seluruh riwayat proyek tepat berada di dalam local disk Anda, kebanyakan pekerjaan terlihat hampir dalam sekejap.

	Sebagai contoh, untuk meramban riwayat dari proyek, Git tidak perlu pergi ke server untuk mendapatkan riwayat dan menampilkannya kepada Anda – dia hanya membacanya langsung dari basis data lokal Anda. Ini berarti Anda melihat riwayat proyek hampir dalam sekejap. Jika Anda ingin melihat perubahan-perubahan yang dikenalkan antara versi sekarang dari sebuah berkas dan berkasnya pada saat sebulan yang lalu, Git dapat mencari berkasnya sebulan yang lalu dan melakukan perhitungan perbedaan secara lokal, bukannya meminta kepada remote server untuk melakukannya atau menarik versi lama dari berkas dari remote server untuk melakukannya secara lokal.

	Ini juga berarti bahwa hanya ada sedikit hal yang tidak dapat Anda lakukan ketika Anda berada di luar jaringan atau di luar VPN. Jika Anda sedang mengendarai pesawat terbang atau kereta dan ingin sedikit bekerja, Anda dapat melakukan commit dengan bahagia hingga Anda mendapat sambungan jaringan untuk mengunggah. Jika Anda pulang dan tidak dapat menggunakan klien VPN dengan wajar, Anda masih dapat bekerja. Pada banyak sistem lain, melakukan hal tersebut adalah tidak mungkin atau sangat susah. Pada Perforce, misalnya, Anda tidak dapat melakukan banyak hal ketika Anda tidak tersambung ke server; dan pada Subversion dan CVS, Anda dapat menyunting berkas, namun Anda tidak dapat melakukan commit tentang perubahan-perubahan ke basis data Anda (karena basis data Anda sedang luring). Ini mungkin tidak terlihat seperti sebuah masalah, namun, Anda mungkin akan terkejut betapa besar perbedaan yang dapat dibuatnya.

	Git Memiliki Integritas
	Semuanya dalam Git telah dilakukan checksum sebelum itu disimpan dan kemudian mengacu pada checksum tersebut. Ini berarti bahwa tidak mungkin untuk mengubah isi dari sebarang berkas atau direktori tanpa diketahui oleh Git. Kemampuan ini terpasang pada Git pada tingkat paling bawah dan terpadu pada filosofinya. Anda tidak dapat kehilangan informasi dalam singgahan atau mendapat berkas yang corrupt yang tidak terlacak oleh Git.

	Cara kerja yang digunakan oleh Git untuk melakukan checksum disebut dengan SHA-1 hash. Ini adalah kumpulan kata sepanjang 40 karakter dari karakter heksadesimal (0-9 dan a-f) dan dihitung berdasarkan isi dari sebuah berkas atau struktur direktori dalam Git. Sebuah SHA-1 hash nampak seperti berikut:

	24b9da6552252987aa493b52f8696cd6d3b00373
	Anda akan melihat nilai hash tersebut di semua tempat pada Git karena dia sering menggunakannya. Nyatanya, Git menyimpan semuanya dalam basis datanya bukan dari nama berkas, namun dari nilai hash isinya.

	Git Umumnya Hanya Menambah Data
	Ketika Anda melakukan aksi dalam Git, hampir semuanya hanya menambahkan data ke basis data Git. Adalah sulit untuk membuat sistem melakukan apapun yang tidak dapat dikembalikan atau membuatnya menghapus data dalam berbagai cara. Seperti pada VCS lain, Anda dapat kehilangan atau mengacak-acak perubahan yang belum Anda commit; namun, setelah Anda melakukan commit snapshot ke Git, akan sangat sulit untuk kehilangan, terutama jika Anda menyimpan ke basis data Anda ke repository lain secara rutin.

	Ini membuat menggunakan Git adalah sebuah kebahagiaan, karena kita tahu kita dapat melakukan uji coba tanpa bahaya dari mengacak-acak hal-hal. Untuk melihat lebih dalam tentang bagaimana Git menyimpan datanya dan bagaimana Anda dapat memulihkan data yang kelihatannya hilang, lihat [_mengembalikan_ke_sebelumnya].

	Tiga Keadaan
	Sekarang, perhatikan. Ini adalah hal utama untuk diingat tentang Git jika Anda ingin sisa perjalanan belajar Anda berjalan dengan lancar. Git memiliki tiga keadaan utama yang berkas-berkas Anda dapat masuk ke dalamnya: committed, modified, dan staged. Committed berarti datanya telah tersimpan dengan aman pada basis data lokal Anda. Modified berarti Anda telah mengubah berkas, namun belum di-commit ke basis data Anda. Staged berarti Anda telah menandai berkas yang telah diubah ke dalam versi sekarang untuk snapshot commit Anda selanjutnya.

	Ini memimpin kita kepada tiga bab utama dalam proyek Git: direktori Git, working directory, dan staging area.

	Working directory
	Figure 6. Working directory, staging area, dan directory Git.
	Directory Git adalah di mana Git menyimpan metadata dan basis data obyek untuk proyek Anda. Ini adalah bagian paling penting tentang Git, dan ini adalah apa yang disalin ketika Anda menggandakan sebuah repository dari komputer lain.

	Working directory adalah sebuah checkout tunggal dari satu versi milik proyek. Berkas-berkas ini ditarik dari basis data yang telah dimampatkan dalam direktori Git dan ditempatkan pada diska untuk Anda gunakan atau sunting.

	Staging area adalah sebuah berkas, umumnya berada pada direktori Git Anda, yang menyimpan informasi tentang apa yang akan menjadi commit Anda selanjutnya. Terkadang disebut juga sebagai index, namun juga sering disebut sebagai staging area

	Alur kerja dasar Git adalah seperti berikut:

	- Anda mengubah berkas dalam working directory Anda.

	- Anda menyiapkan berkasnya, menambah snapshot darinya ke staging area Anda.

	- Anda melakukan commit, yang mengambil berkas-berkas yang ada pada staging area dan menyimpan snapshot tersebut secara tetap ke dalam direktori Git Anda.

	Jika sebuah versi tertentu dari sebuah berkas ada pada direktori Git, itu dianggap telah committed. Jika itu diubah, namun telah ditambahkan ke staging area, maka itu staged. Dan jika itu telah diubah sejak setelah di-check out, namun belum staged, maka itu adalah modified. Dalam [_bab_dasar-dasar_git], Anda akan belajar lebih banyak tentang keadaan tersebut dan bagaimana Anda dapat memanfaatkannya atau melewati semua ke bagian staged.

8.) Markdown
	Tentang Markdown
	Dibuat oleh John Gruber, Markdown adalah sintaks format teks biasa yang menjadikan pembuatan elemen HTML dasar menjadi lebih mudah.

	Alih-alih menggunakan tag HTML (yang, dikatakan, membutuhkan banyak waktu untuk menulisnya) tugas Markdown adalah menyingkirkan dari proses berpikir Anda, sehingga Anda dapat fokus pada konten. Karena sintaksnya sangat mendasar, mudah untuk menulis dan membaca markdown. Nantinya dalam tutorial ini, kita akan berjalan melalui langkah-langkah membuat dokumentasi tema menggunakan Markdown, jadi Anda akan melihat betapa ringan dan cepatnya!

	Mengkonversi Markdown
	Begitu Anda berhasil mengatasi penulisan Markdown, Anda memerlukan beberapa jenis aplikasi parsing untuk mengubah Markdown menjadi markup HTML.

	Konverter Markdown asli dibuat di Perl, namun sejak saat itu banyak aplikasi (di beberapa platform) telah muncul. Mari kita lihat beberapa pilihan, baik online dan berjalan di sistem Anda sendiri.

	Dingus (Online)
	Dingus adalah aplikasi web yang dibuat oleh orang yang sama yang telah memperkenalkan Anda Markdown. Cukup copy dan paste kode Markdown Anda dari editor teks (atau masukkan di area teks) dan dengan satu klik tombol, kode HTML Anda (dan juga pratinjau) akan muncul. Tidak ada yang mewah, tapi cara mudah untuk mengubah markdown menjadi HTML.

	MarkdownPad (Windows)
	MarkdownPad adalah aplikasi Windows yang hebat yang memungkinkan Anda membuat file Markdown dengan mudah (dan gratis!) Ini termasuk fitur-fitur hebat seperti pratinjau HTML instan, format yang mudah dengan pintasan keyboard, kustomisasi CSS, ekspor HTML dan bahkan mode "distraction free".

	Mou (OS X)
	Mou adalah aplikasi Mac yang bagus dan gratis yang memungkinkan Anda menulis Markdown secara sederhana dan indah. Memiliki fitur hebat seperti styling kustom, pintasan keyboard, HTML langsung, ekspor HTML (dengan styling CSS opsional), ekspor PDF, dukungan pendiktean, dan banyak lagi. Untuk tutorial ini, kita akan menggunakan Mou untuk membuat dokumentasi tema kita.

	MarkdownNote (OS X & iOS)
	MarkdownNote adalah aplikasi hebat lainnya untuk menulis Markdown, dan aplikasi iOS sangat cocok jika Anda ingin menulis Markdown saat dalam perjalanan. Sama seperti aplikasi lain yang kita bahas, ada beberapa fitur hebat, termasuk pratinjau HTML langsung, pintasan keyboard, dan sinkronisasi Dropbox.

	Membuat Dokumentasi Tema
	Sejauh ini, kita telah membahas apa itu Markdown dan melihat beberapa alat yang dapat Anda gunakan untuk menuliskan Markdown. Sekarang mari kita membuat beberapa dokumentasi tema untuk tema yang tidak ada, mencakup apa yang biasanya Anda sertakan dalam dokumentasi, sintaks Markdown dan praktik terbaik.

	Sintaks Markdown
	Selama langkah-langkah berikut kita akan melihat Markdown karena berlaku untuk kebutuhan kita. Untuk melihat lebih dalam pada sintaks Markdown, lihat Markdown: Seluk beluk pada Nettuts+.

	Apa yang Harus Disertakan Sebuah File Dokumentasi?
	Karena Anda sudah mengetahui seluk beluk dari tema/template/aplikasi web Anda, mungkin agak membosankan untuk membahas dasar-dasarnya. Tujuan dari file dokumentasi adalah untuk melayani sebagai panduan bagi pengguna dan pembeli lainnya. Seringkali, ada instalasi, penyesuaian, dan beberapa tweak yang melibatkan pengguna yang perlu diketahui - dan tugas Anda untuk mendidik mereka. Inilah yang mungkin ingin kita sertakan:

	Informasi
	Penulis
	Tanggal Pembuatan
	Versi
	Info Kontak.
	Struktur File
	HTML
	CSS
	Javascript
	Struktur File Individu
	Struktur HTML
	Struktur CSS
	Gaya Kustom
	File Tweak
	CSS Tweak
	Javascript Tweak
	Kompatibilitas Browser
	Changelog
	Ingat, dokumentasi harus cukup sederhana bagi siapa saja yang memiliki pengetahuan dasar untuk mengerti, namun juga mencakup cara mengubah file penting. Misalnya, Anda tidak perlu menunjukkan bagaimana mengubah nilai CSS tertentu, namun Anda harus menunjukkan cara mengakses file-file ini.

	Langkah 1: Menyiapkan File Markdown
	Sekarang saatnya untuk hal-hal menyenangkan! Silakan buka editor Markdown Anda (saya akan menggunakan Mou untuk Mac). Buat header untuk file dokumentasi Anda:

	#Theme Documentation
	Elemen heading dapat ditulis hanya dengan menambahkan satu sampai enam # di depan konten. Pada contoh di atas, kita menggunakan satu tanda # untuk membuat elemen h1 dengan teks 'Theme Documentation'. Jika Anda ingin membuat elemen h3, Anda akan menulis ###Heading 3.

	Advertisement
	Langkah 2: Informasi Tema
	Bagian penting untuk ditambahkan dalam dokumentasi Anda adalah bagian informasi.

	Hanya dengan melihat dua sumber yang berbeda, Anda bisa langsung melihat Markdown lebih intuitif untuk dipahami dan diciptakan. Alih-alih terus-menerus harus menambahkan < dan >, Markdown memungkinkan Anda untuk fokus pada konten. Untuk menekankan, tambahkan tanda bintang sebelum dan sesudah teks (misalnya *Emphasized Text*). Untuk memperjelas, tambahkan dua tanda bintang sebelum dan sesudah teks (misalnya **Emboldened Text**). Untuk menambahkan jeda baris, cukup tambahkan dua spasi pada titik yang Anda inginkan untuk memasukkan jeda baris.

	Langkah 3: Menambahkan Daftar Isi
	Sekarang mari tambahkan daftar konten ke dalam file Markdown kita:

	##Table of Contents
	1. HTML Structure
	2. CSS Files
	3. Javascript Files
	4. PSD Files
	5. Theme Styles
	6. Tweaking Javascript
	7. Tweaking CSS
	8. Browser Compatibility
	***
	Jika kita membuat ini di HTML, berikut adalah bagaimana tampilannya:

	<h2>Table of Contents</h2>
	<ol>
	   <li>HTML Structure</li>
	   <li>CSS Files</li>
	   <li>Javascript Files</li>
	   <li>PSD Files</li>
	   <li>Theme Styles</li>
	   <li>Tweaking Javascript</li>
	   <li>Tweaking CSS</li>
	   <li>Browser Compatibility</li>
	</ol>
	<hr />
	Alih-alih harus membuat ordered list dan daftar item terpisah, cukup tulis 1. First Element dan lanjutkan menambahkan item tambahan.

	Langkah 4: Struktur HTML
	Penting untuk membiarkan pengguna Anda tahu bagaimana file situs diletakkan. Karena kita membuat dokumentasi untuk sebuah tema, kita harus menjelaskan bagaimana kode HTML dari tema terstruktur. Kita bisa menjelaskannya dengan kode berikut:

	##1. HTML Structure
	The HTML Structure for each page is as follows:
	 
	* Meta
	* Link to CSS Files
	* Header
	  * Logo
	    * Social Links
	* Navigation
	* Main Content
	    * Content Slider
	    * Articles
	* Sidebar
	    * Search
	    * Post Archives
	    * Mailing List
	* Link to Javascript Files
	* Javascript
	***
	Sederhana. Untuk membuat daftar isi kita, kita menggunakan ordered list. Pada bagian ini, kita menggunakan undordered list bersarang. Untuk membuat unordered list dalam Markdown, cukup tambahkan tanda bintang dan spasi sebelum teks (misalnya * Item 1). Untuk menyarangkan item daftar, cukup indent ke dalam dan buat item daftar lainnya.

	Advertisement
	Langkah 5: File CSS
	Terutama dalam tema, dokumentasi CSS sangat penting. Sebaiknya memperjelas file-file CSS yang berbeda yang disertakan dalam tema, serta deskripsi singkat setiap file:

	##2. CSS Files
	There are 3 CSS files in this theme:
	 
	* main.css
	* colors.css
	* skeleton.css
	 
	#####main.css
	This CSS file is the main stylesheet for the theme. It holds all the values for the different elements of theme and the default color scheme.
	#####colors.css
	This CSS file holds the styling of all the other colors schemes that are included in the theme.
	#####skeleton.css
	This CSS file allows the theme to be responsive, adapting to different screen sizes. 
	***
	Pastikan untuk menggunakan judul untuk memisahkan bagian yang berbeda dari file dokumentasi. File dokumentasi yang ditata dengan baik akan menyebabkan lebih sedikit pengguna yang kebingungan!

	Langkah 6: File Javascript
	Jika tema Anda menyertakan file Javascript, ada baiknya untuk setidaknya menjelaskannya di dokumentasi:

	##3. Javascript Files
	There are 2 Javascript files in this theme:
	 
	* jquery.js
	* slider.js
	 
	#####jquery.js
	This theme uses the jQuery Javascript library.
	#####slider.js
	The content slider in the theme runs on this Javascript file. There are some settings that can be tweaked, this will be covered in the 'Tweaking Javascript' section.
	***
	Pastikan Anda bukan hanya mencantumkan, namun menjelaskan file-file tersebut dalam tema Anda. Ini akan mempermudah pengguna memahami isi setiap file, dan memutuskan apakah mereka ingin mengacaukannya atau tidak.

	Langkah 7: File PSD
	Meskipun ada bagian terpisah untuk template PSD di ThemeForest, banyak penulis memutuskan untuk menyertakan file PSD dengan template kode mereka untuk memungkinkan kebebasan pengguna membuat perubahan desain. Jika tema Anda menyertakan file PSD, mungkin ide bagus untuk menggambarkannya sama seperti yang telah kami lakukan dengan semua file lainnya:

	##4. PSD Files
	Included in this theme is 5 different PSD files:
	 
	1. homepage.psd
	2. about.psd
	3. portfolio.psd
	4. blog.psd
	5. contact.psd
	 
	These PSD files will be handy if you would like to make any changes to the theme's design. You can also create a new page layout using the existing PSD files as a base to work with.
	***
	Praktik terbaik untuk memberi nama file PSD Anda dengan jelas (mis., full-width-page.psd) dibandingkan dengan nama yang tidak jelas (misalnya template-003.psd). Dengan cara ini, pengguna bisa menemukan apa yang mereka butuhkan tanpa harus membuka setiap file.

	Langkah 8: Gaya Tema
	Kemungkinan besar, tema Anda akan mencakup pilihan skema warna yang dapat dipilih pengguna Anda. Jika demikian, pastikan bahwa Anda menjelaskan bagaimana hal ini dilakukan:

	##5. Theme Styles
	Included with this theme are 10 different theme styles:
	 
	1. Light
	2. Dark
	3. Grey
	4. Green
	5. Red
	6. Orange
	7. Blue
	8. Purple
	9. Brown
	10. Dark Blue
	 
	To change these styles, go to the WordPress backend, select **Options > Styles** and select the style you would like.
	***
	Pada contoh di atas, saya telah mencantumkan skema warna yang berbeda yang disertakan dalam tema dan menunjukkan bagaimana cara mengubahnya.

	Langkah 9: Javascript Tweak
	Jika kode Anda menyertakan file Javascript yang memiliki parameter penyesuaian (misalnya skrip slider), sebaiknya Anda menunjukkan pengguna cara memanipulasi nilai-nilai tersebut:

	##6. Tweaking Javascript
	The content slider in the theme runs off of slider.js, and there are a couple of values that can be changed to alter the look and feel of the slider.
	#####Changing Values
	In slider.js, you can alter these values:
	 
	<code>auto: true</code>  
	*Boolean: Animate automatically, true or false*  
	 
	<code>speed: 1000</code>  
	*Integer: Speed of the transition, in milliseconds*
	 
	 
	<code>pager: true</code>  
	*Boolean: Show pager, true or false*  
	 
	<code>nav: false</code>  
	*Boolean: Show navigation, true or false*  
	***
	Kode di atas menguraikan bagaimana pengguna dapat mengubah nilai-nilai. Untuk memberi gaya kode, bungkus teks yang relevan di dalam tag <code>. Aplikasi seperti Mou menambahkan styling ke elemen-elemen ini di pratinjau langsung, dan Anda juga dapat mengekspor kode untuk menjaga styling. Kami akan berbicara sedikit tentang mengekspor dokumentasi Anda nanti.

	Langkah 10: CSS Tweak
	File CSS sangat sering disesuaikan oleh pengguna. Mereka pasti akan menganggapnya bermanfaat jika Anda menambahkan sebuah bagian ke dokumentasi yang menunjukkan bagaimana mengakses file CSS sehingga mereka dapat mengeditnya.

	##7. Tweaking CSS
	The theme is build on a responsive framework, which allows content to be seen optimally on all screen sizes.
	#####Changing the CSS
	Start off by going into the WordPress backend, **Themes > Theme > View Source**. Select the *style.css* file to view and have the ability to edit the code.
	 
	Here, you can change things like the fonts, sizes, colors, etc.
	***
	Sekarang pengguna memiliki akses ke file CSS, mereka dapat membuat perubahan yang mereka inginkan.

	Langkah 11: Kompatibilitas Browser
	Sebaiknya beri tahu pengguna tentang apa pun masalah kompatibilitas browser:

	##8. Browser Compatibility
	This theme works well (-) or great (X) in the following browsers:

	Langkah 12: Menyelesaikan Dokumentasi
	Untuk melengkapi dokumentasi kita, kita akan menambahkan sebuah bagian untuk memberi tahu pengguna cara menghubungi kita jika mereka memiliki pertanyaan lebih lanjut. Mari tambahkan sedikit kode ini:

	####Theme by Suhail Dawood
	If you have any other questions that aren't covered in the documentation, feel free to e-mail <email@tutsplus.com> or add a new post on the [forum](http://forum.tutsplus.com/ "visit the forum").
	Untuk menghubungkan e-mail dengan menggunakan markdown, cukup bungkus alamat e-mail Anda antara chevron (misalnya <email@tutsplus.com>).

	Menambahkan link di Mardown cukup sederhana. <a href="http://tutsplus.com" alt="The World's Leading Tutorial Network">Tuts+ adalah hyperlink yang Anda inginkan muncul di HTML. Teks harus ditempatkan di dalam kurung persegi [Tuts+]. Segera setelah itu, Anda memiliki alamat situs web yang dibungkus di antara tanda kurung (mis. (http://www.tutsplus.com/)) dan teks alt ditempatkan dalam tanda petik ganda di dalam tanda kurung (mis. (http://www.tutsplus.com/ "The World's Leading Tutorial Network")).

	Kode Markdown Akhir
	Berikut adalah kode akhir Markdown kita untuk dokumentasi ini:

	##Table of Contents
	1. HTML Structure
	2. CSS Files
	3. Javascript Files
	4. PSD Files
	5. Theme Styles
	6. Tweaking Javascript
	7. Tweaking CSS
	8. Browser Compatibility
	***
	##1. HTML Structure
	The HTML Structure for each page is as follows:
	 
	* Meta
	* Link to CSS Files
	* Header
	    * Logo
	    * Social Links
	* Navigation
	* Main Content
	    * Content Slider
	    * Articles
	* Sidebar
	    * Search
	    * Post Archives
	    * Mailing List
	* Link to Javascript Files
	* Javascript
	***
	##2. CSS Files
	There are 3 CSS files in this theme:
	 
	* main.css
	* colors.css
	* skeleton.css
	 
	#####main.css
	This CSS file is the main stylesheet for the theme. It holds all the values for the different elements of theme and the default color scheme.
	#####colors.css
	This CSS file holds the styling of all the other colors schemes that are included in the theme.
	#####skeleton.css
	This CSS file allows the theme to be responsive, adapting to different screen sizes. 
	***
	##3. Javascript Files
	There are 2 Javascript files in this theme:
	 
	* jquery.js
	* slider.js
	 
	#####jquery.js
	This theme uses the jQuery Javascript library.
	#####slider.js
	The content slider in the theme runs on this Javascript file. There are some settings that can be tweaked, this will be covered in the 'Tweaking Javascript' section.
	***
	##4. PSD Files
	Included in this theme is 5 different PSD files:
	 
	1. homepage.psd
	2. about.psd
	3. portfolio.psd
	4. blog.psd
	5. contact.psd
	 
	These PSD files will be handy if you would like to make any changes to the theme's design. You can also create a new page layout using the existing PSD files as a base to work with.
	***
	##5. Theme Styles
	Included with this theme are 10 different theme styles:
	 
	1. Light
	2. Dark
	3. Grey
	4. Green
	5. Red
	6. Orange
	7. Blue
	8. Purple
	9. Brown
	10. Dark Blue
	 
	To change these styles, go to the WordPress backend, select **Options > Styles** and select the style you would like.
	***
	##6. Tweaking Javascript
	The content slider in the theme runs off of slider.js, and there are a couple of values that can be changed to alter the look and feel of the slider.
	#####Changing Values
	In slider.js, you can alter these values:
	 
	<code>auto: true</code>  
	*Boolean: Animate automatically, true or false*  
	 
	<code>speed: 1000</code>  
	*Integer: Speed of the transition, in milliseconds*
	 
	 
	<code>pager: true</code>  
	*Boolean: Show pager, true or false*  
	 
	<code>nav: false</code>  
	*Boolean: Show navigation, true or false*  
	***
	##7. Tweaking CSS
	The theme is build on a responsive framework, which allows content to be seen optimally on all screen sizes.
	#####Changing the CSS
	Start off by going into the WordPress backend, **Themes > Theme > View Source**. Select the *style.css* file to view and have the ability to edit the code.
	 
	Here, you can change things like the fonts, sizes, colors, etc.
	***
	##8. Browser Compatibility
	This theme works well (-) or great (X) in the following browsers:
	 
	**IE 6-8** -  
	**IE 9+** X  
	**Chrome** X  
	**Firefox** X  
	**Safari** X  
	**Opera** X
	***
	####Theme by Suhail Dawood
	Mengekspor Dokumentasi
	Setelah kita selesai membuat file dokumentasi, saatnya mengkonversi Markdown menjadi HTML atau file PDF. Saya akan menggunakan Mou untuk mengekspor dokumentasi saya, namun langkah-langkahnya bersifat umum dan berlaku untuk sebagian besar aplikasi.

	Mou
	Mengekspor ke HTML
	Untuk mengekspor dokumentasi Anda ke HTML, cukup pilih File > Export > HTML. Namai file dokumentasi Anda dan centang/hapus centang pada 'Include CSS' tergantung apakah Anda ingin styling yang sama ditampilkan dalam aplikasi untuk diterapkan ke file HTML Anda. Mou tidak akan membuat file CSS yang terpisah, namun menambahkan styling ke file HTML. Mou juga membuat tag yang diperlukan seperti html, doctypehead, dll.

	Mengekspor ke PDF
	Jika Anda ingin mengekspor dokumentasi Anda ke PDF, pilih File > Export > PDF. Dalam kasus Mou, semua styling yang ditampilkan dalam pratinjau langsung HTML akan disertakan dalam file PDF.

	Dan kita sudah selesai! Dokumentasi yang jelas dan mudah dibaca untuk klien, pelanggan dan kolega. Unduh file sumber untuk tutorial ini dan periksa file .md .html dan .pdf yang dihasilkan.

	Ikhtisar Sintaks Markdown
	Berikut adalah perbandingan singkat dari sintaks HTML dan Markdown yang kita bahas dalam tutorial ini

	<h1>heading One</h1>	#Heading One
	<h2>Heading Two</h2>	##Heading Two
	<h3>Heading Three</h3>	###Heading Three
	<h4>Heading Four</h4>	####Heading Four
	<h5>Heading Five</h5>	#####Heading Five
	<h6>Heading Six</h6>	#######Heading Six
	<hr />	***
	<em>Teks Ditekankan</em>	*Teks Ditekankan*
	<strong>Teks Dipertegas</strong>	**Teks Dipertegas**
	<ol><li>List Element</li></ol>	1. List Element
	<ul><li>List Element</li></ul>	* List Element
	<code>Code</code>	<code>Code</code>
	<a href="mailto:email@tutsplus.com"> email@tutsplus.com</a>	<email@tutsplus.com>
	<a href="http://www.tutsplus.com/" alt="Description">Forum</a>

9.)	Impor repositori dari GitHub atau GitLab
	- Mengimpor repositori ke Bitbucket
	- Pilih tombol Buat dan pilih  Repositori  dari menu tarik-turun.
	- Klik  Impor repositori  dari   dialog Buat repositori baru .
	- Masukkan URL -nya .
	- Pilih Ruang Kerja .
	- Pilih Proyek .
	- Masukkan  Nama  untuk repositori baru Anda.
	- Jika Anda ingin repositori menjadi publik, hapus centang  Ini adalah repositori pribadi.
	- Pilih  Impor repositori .
	Setelah repositori diimpor, Anda dapat mulai bekerja pada sistem lokal Anda dengan mengkloning repositori Anda 

10.) Git for single person developement (Git untuk pengembangan satu orang)

	Jika Anda baru memulai dengan kontrol versi, untuk proyek satu orang, maka jangan khawatir tentang semua alur kerja itu dan lain-lain pada awalnya. Pertama, biasakan untuk berkomitmen.

	Apakah Anda baru saja menjalankan program dan menguji sesuatu, dan berhasil? Hebat, berkomitmen. Akan melakukan sesuatu yang Anda tidak yakin akan berhasil? Melakukan. Berkomitmen lebih awal dan sering. Hal yang menyenangkan tentang git adalah komit tidak dapat dibatalkan jika Anda memilih tempat yang buruk untuk melakukan (petunjuk: jika tidak dikompilasi, itu mungkin tempat yang buruk - tetapi ada pengecualian untuk ini, setelah Anda merasa nyaman dengan git rebase -idan git add -i(semacam alat canggih, jadi biasakan dulu dasar-dasarnya! (kurung bersarang itu menyenangkan!))).

	Sekarang, tentang beralih fokus - git memiliki sejumlah alat yang berguna untuk ini.

	Misalnya, jika Anda ingin memperbaiki bug, tetapi sudah memiliki banyak pekerjaan lain...

	git stash save
	Git kemudian mengambil semua perubahan yang tidak dikomit, menyimpannya, dan kembali ke komit terakhir. Anda dapat memperbaiki bug, menguji, melakukan, lalu

	git stash pop
	Semua perubahan itu kemudian diterapkan kembali di atas perbaikan bug.

	Jika Anda sedang mengerjakan fitur kecil, tetapi kemudian menyadari bahwa ini sebenarnya agak rumit dan Anda mungkin akan melakukan lebih dari sekali...

	git checkout -b mynewbranch
	Dan begitulah - Anda sekarang berada di cabang baru. Anda dapat kembali ke cabang lain kapan saja dengan

	git checkout someotherbranch
	Anda dapat menggunakan ini bersama git stashuntuk menyimpan perubahan yang tidak dikomit, lalu bertukar ke cabang lain untuk melakukan sesuatu yang sama sekali berbeda. Dan ketika Anda ingin kembali, git checkout mynewbranch.

	Sebagai alat yang sedikit lebih canggih, jika Anda memiliki perbaikan bug kecil yang harus dibuat, dan tidak ingin repot dengan semua hal penyimpanan, Anda dapat melakukannya

	git add -i
	# select what changes to include
	git commit # commits only what you selected
	Ini berkat indeks git - git add -imemungkinkan Anda memilih, hingga ke tingkat baris individual, persisnya apa yang akan disalin dari copy pekerjaan ke indeks, lalu git commitmenyimpannya sebagai komit. Dengan melakukan ini, Anda dapat dengan cepat dan mudah menghilangkan perbaikan kecil dari kekacauan perubahan lainnya. Namun, perhatikan bahwa ini berarti Anda baru saja melakukan sesuatu yang belum pernah dikompilasi atau diuji dalam bentuk itu; jadi perlu perhatian untuk tidak melakukan sesuatu yang benar-benar rusak (Anda biasanya harus menghindari melakukan kode yang benar-benar rusak karena rusak git bisect- alat yang sangat berguna untuk melacak regresi).

	Setelah Anda terbiasa dengan aliran dasar ini, Anda dapat mulai menambahkan beberapa proses ke dalamnya. Misalnya, Anda dapat menyimpan v1.xcabang untuk perbaikan bug hanya untuk seri 1.x. Atau terserah. Gunakan alur kerja yang sesuai untuk Anda.

11.) Pengembangan Aplikasi Menggunakan Git 
	Pengembangan aplikasi biasanya dilakukan bersama-sama secara tim, terutama untuk aplikasi yang memiliki scope yang besar. Artinya, banyak fitur yang harus dibuat dalam pengembangan aplikasi tersebut.

	Pembagian atau modularisasi pekerjaan dalam pembangunan aplikasi biasa dilakukan berdasarkan fitur, subsistem, fungsi, dan sebagainya.

	Tantangan dari bekerja secara tim ini adalah bagaimana menggabungkan pekerjaan-pekerjaan yang dilakukan terpisah-pisah ini menjadi sebuah sistem utuh ketika di-deploy.

	Sebelum membahas lebih lanjut soal Git, mungkin kita perlu tahu apa itu Git sebenarnya.

	Git merupakan perangkat lunak yang bisa digunakan untuk mengelola pengerjaan perangkat lunak yang terpisah-pisah dari setiap pengembang, menjadi sebuah sistem utuh.

	Tulisan ini tidak akan membahas mengenai cara instalasi Git.

	Namun lebih kepada Git secara konseptual, dan memperkenalkan beberapa istilah dalam penggunaan Git, beserta artinya. Cara instalasi Git akan disampaikan pada tulisan berikutnya.

	Pengenalan Git

	Git adalah sebuah perangkat lunak open source yang dapat digunakan untuk mengelola pengembangan perangkat lunak (Software Management Tool). Ini agar pengembangan aplikasi bisa dikerjakan secara terdistribusi.

	Git sering disebut sebagai perangkat lunak version control, yang artinya setiap perubahan yang dibuat ketika melakukan pengembangan perangkat lunak akan disimpan.

	Jadi, kapanpun kita ingin kembali ke sebuah kondisi penyimpanan tertentu, kita bisa melakukannya dengan mudah.

	Masa-masa sebelum Git
	Ketika perangkat lunak dibuat, sedangkan version control belum ada, pengembang aplikasi biasanya menulis source code pada komputer masing-masing.

	Kemudian setelah kodenya dianggap selesai, kode tersebut diberikan melalui flash disk atau media lain kepada pimpinan tim (atau orang lain yang dianggap bisa menggabungkan kode), dan pimpinan tim tersebut melakukan integrasi kode yang dibuat oleh rekan-rekan setimnya.

	Di sinilah terdapat beban berat yang diemban para integrator, karena mereka harus tahu file mana yang harus diubah, dan harus mengingat-ingat apa saja bagian yang berubah, karena jika integrasi gagal, maka dia harus mengembalikannya ke kondisi sistem sebelumnya yang dapat berjalan dengan baik.

	Zaman berkembang, dan pengembang mulai memanfaatkan layanan cloud storage, seperti Dropbox atau Google Drive untuk berbagi berkas atau direktori, kemudian juga dimanfaatkan untuk mengembangkan aplikasi bersama-sama pada direktori yang dibagikan ini.

	Masalah yang muncul ketika hal ini dilakukan adalah terjadinya konflik ketika pengembang yang berbeda mengubah satu file yang sama.

	Kemudian para pengembang ini mulai saling menuding, muncul keributan, dan akhirnya menimbulkan perpecahan. Mungkin hal ini berlebihan, namun bukan tidak mungkin untuk terjadi.

	Untunglah version control menjadi solusi permasalahan ini.

	Perannya adalah untuk membagi-bagi pekerjaan setiap pengembang, kemudian menyatukannya dengan mekanisme dan prosedur yang rapi. Tujuannya adalah memperkecil kemungkinan adanya konflik pada kode yang dibuat oleh para pengembang.